"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var y=require("@walletconnect/core"),x=require("@walletconnect/logger"),b=require("@walletconnect/types"),r=require("@walletconnect/utils"),J=require("pino"),p=require("@walletconnect/time"),d=require("@walletconnect/jsonrpc-utils");function z(o){return o&&typeof o=="object"&&"default"in o?o:{default:o}}var X=z(J);function g(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}var G=g;g.EventEmitter=g,g.prototype._events=void 0,g.prototype._maxListeners=void 0,g.defaultMaxListeners=10,g.prototype.setMaxListeners=function(o){if(!F(o)||o<0||isNaN(o))throw TypeError("n must be a positive number");return this._maxListeners=o,this},g.prototype.emit=function(o){var i,e,s,t,n,a;if(this._events||(this._events={}),o==="error"&&(!this._events.error||R(this._events.error)&&!this._events.error.length)){if(i=arguments[1],i instanceof Error)throw i;var c=new Error('Uncaught, unspecified "error" event. ('+i+")");throw c.context=i,c}if(e=this._events[o],M(e))return!1;if(w(e))switch(arguments.length){case 1:e.call(this);break;case 2:e.call(this,arguments[1]);break;case 3:e.call(this,arguments[1],arguments[2]);break;default:t=Array.prototype.slice.call(arguments,1),e.apply(this,t)}else if(R(e))for(t=Array.prototype.slice.call(arguments,1),a=e.slice(),s=a.length,n=0;n<s;n++)a[n].apply(this,t);return!0},g.prototype.addListener=function(o,i){var e;if(!w(i))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",o,w(i.listener)?i.listener:i),this._events[o]?R(this._events[o])?this._events[o].push(i):this._events[o]=[this._events[o],i]:this._events[o]=i,R(this._events[o])&&!this._events[o].warned&&(M(this._maxListeners)?e=g.defaultMaxListeners:e=this._maxListeners,e&&e>0&&this._events[o].length>e&&(this._events[o].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[o].length),typeof console.trace=="function"&&console.trace())),this},g.prototype.on=g.prototype.addListener,g.prototype.once=function(o,i){if(!w(i))throw TypeError("listener must be a function");var e=!1;function s(){this.removeListener(o,s),e||(e=!0,i.apply(this,arguments))}return s.listener=i,this.on(o,s),this},g.prototype.removeListener=function(o,i){var e,s,t,n;if(!w(i))throw TypeError("listener must be a function");if(!this._events||!this._events[o])return this;if(e=this._events[o],t=e.length,s=-1,e===i||w(e.listener)&&e.listener===i)delete this._events[o],this._events.removeListener&&this.emit("removeListener",o,i);else if(R(e)){for(n=t;n-- >0;)if(e[n]===i||e[n].listener&&e[n].listener===i){s=n;break}if(s<0)return this;e.length===1?(e.length=0,delete this._events[o]):e.splice(s,1),this._events.removeListener&&this.emit("removeListener",o,i)}return this},g.prototype.removeAllListeners=function(o){var i,e;if(!this._events)return this;if(!this._events.removeListener)return arguments.length===0?this._events={}:this._events[o]&&delete this._events[o],this;if(arguments.length===0){for(i in this._events)i!=="removeListener"&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events={},this}if(e=this._events[o],w(e))this.removeListener(o,e);else if(e)for(;e.length;)this.removeListener(o,e[e.length-1]);return delete this._events[o],this},g.prototype.listeners=function(o){var i;return!this._events||!this._events[o]?i=[]:w(this._events[o])?i=[this._events[o]]:i=this._events[o].slice(),i},g.prototype.listenerCount=function(o){if(this._events){var i=this._events[o];if(w(i))return 1;if(i)return i.length}return 0},g.listenerCount=function(o,i){return o.listenerCount(i)};function w(o){return typeof o=="function"}function F(o){return typeof o=="number"}function R(o){return typeof o=="object"&&o!==null}function M(o){return o===void 0}const L="wc",D=2,C="client",A=`${L}@${D}:${C}:`,V={name:C,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},H={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_event:"session_event",proposal_expire:"proposal_expire"},Z={database:":memory:"},B={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Q="history",W="0.3",U="proposal",ee=p.THIRTY_DAYS,$="session",N=p.SEVEN_DAYS,k="engine",f={wc_sessionPropose:{req:{ttl:p.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:p.FIVE_MINUTES,prompt:!1,tag:1101}},wc_sessionSettle:{req:{ttl:p.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:p.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:p.ONE_DAY,prompt:!1,tag:1104},res:{ttl:p.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:p.ONE_DAY,prompt:!1,tag:1106},res:{ttl:p.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:p.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:p.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:p.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:p.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:p.ONE_DAY,prompt:!1,tag:1112},res:{ttl:p.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:p.THIRTY_SECONDS,prompt:!1,tag:1114},res:{ttl:p.THIRTY_SECONDS,prompt:!1,tag:1115}}};var se=Object.defineProperty,te=Object.defineProperties,ie=Object.getOwnPropertyDescriptors,Y=Object.getOwnPropertySymbols,re=Object.prototype.hasOwnProperty,ne=Object.prototype.propertyIsEnumerable,K=(o,i,e)=>i in o?se(o,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[i]=e,I=(o,i)=>{for(var e in i||(i={}))re.call(i,e)&&K(o,e,i[e]);if(Y)for(var e of Y(i))ne.call(i,e)&&K(o,e,i[e]);return o},j=(o,i)=>te(o,ie(i));class oe extends b.IEngine{constructor(i){super(i),this.name=k,this.events=new G,this.initialized=!1,this.ignoredPayloadTypes=[r.TYPE_1],this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.client.core.pairing.register({methods:Object.keys(f)}),this.initialized=!0)},this.connect=async e=>{this.isInitialized(),await this.isValidConnect(e);const{pairingTopic:s,requiredNamespaces:t,relays:n}=e;let a=s,c,l=!1;if(a&&(l=this.client.core.pairing.pairings.get(a).active),!a||!l){const{topic:_,uri:E}=await this.client.core.pairing.create();a=_,c=E}const h=await this.client.core.crypto.generateKeyPair(),u={requiredNamespaces:t,relays:n??[{protocol:y.RELAYER_DEFAULT_PROTOCOL}],proposer:{publicKey:h,metadata:this.client.metadata}},{reject:m,resolve:S,done:P}=r.createDelayedPromise();if(this.events.once(r.engineEvent("session_connect"),async({error:_,session:E})=>{if(_)m(_);else if(E){E.self.publicKey=h;const v=j(I({},E),{requiredNamespaces:t});await this.client.session.set(E.topic,v),await this.setExpiry(E.topic,E.expiry),a&&await this.client.core.pairing.updateMetadata({topic:a,metadata:E.peer.metadata}),S(v)}}),!a){const{message:_}=r.getInternalError("NO_MATCHING_KEY",`connect() pairing topic: ${a}`);throw new Error(_)}const O=await this.sendRequest(a,"wc_sessionPropose",u),q=r.calcExpiry(p.FIVE_MINUTES);return await this.setProposal(O,I({id:O,expiry:q},u)),{uri:c,approval:P}},this.pair=async e=>(this.isInitialized(),await this.client.core.pairing.pair(e)),this.approve=async e=>{this.isInitialized(),await this.isValidApprove(e);const{id:s,relayProtocol:t,namespaces:n}=e,{pairingTopic:a,proposer:c,requiredNamespaces:l}=this.client.proposal.get(s),h=await this.client.core.crypto.generateKeyPair(),u=c.publicKey,m=await this.client.core.crypto.generateSharedKey(h,u),S={relay:{protocol:t??"irn"},namespaces:n,requiredNamespaces:l,controller:{publicKey:h,metadata:this.client.metadata},expiry:r.calcExpiry(N)};await this.client.core.relayer.subscribe(m);const P=await this.sendRequest(m,"wc_sessionSettle",S),{done:O,resolve:q,reject:_}=r.createDelayedPromise();this.events.once(r.engineEvent("session_approve",P),({error:v})=>{v?_(v):q(this.client.session.get(m))});const E=j(I({},S),{topic:m,acknowledged:!1,self:S.controller,peer:{publicKey:c.publicKey,metadata:c.metadata},controller:h});return await this.client.session.set(m,E),await this.setExpiry(m,r.calcExpiry(N)),a&&await this.client.core.pairing.updateMetadata({topic:a,metadata:E.peer.metadata}),a&&s&&(await this.sendResult(s,a,{relay:{protocol:t??"irn"},responderPublicKey:h}),await this.client.proposal.delete(s,r.getSdkError("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:a})),{topic:m,acknowledged:O}},this.reject=async e=>{this.isInitialized(),await this.isValidReject(e);const{id:s,reason:t}=e,{pairingTopic:n}=this.client.proposal.get(s);n&&(await this.sendError(s,n,t),await this.client.proposal.delete(s,r.getSdkError("USER_DISCONNECTED")))},this.update=async e=>{this.isInitialized(),await this.isValidUpdate(e);const{topic:s,namespaces:t}=e,n=await this.sendRequest(s,"wc_sessionUpdate",{namespaces:t}),{done:a,resolve:c,reject:l}=r.createDelayedPromise();return this.events.once(r.engineEvent("session_update",n),({error:h})=>{h?l(h):c()}),await this.client.session.update(s,{namespaces:t}),{acknowledged:a}},this.extend=async e=>{this.isInitialized(),await this.isValidExtend(e);const{topic:s}=e,t=await this.sendRequest(s,"wc_sessionExtend",{}),{done:n,resolve:a,reject:c}=r.createDelayedPromise();return this.events.once(r.engineEvent("session_extend",t),({error:l})=>{l?c(l):a()}),await this.setExpiry(s,r.calcExpiry(N)),{acknowledged:n}},this.request=async e=>{this.isInitialized(),await this.isValidRequest(e);const{chainId:s,request:t,topic:n}=e,a=await this.sendRequest(n,"wc_sessionRequest",{request:t,chainId:s}),{done:c,resolve:l,reject:h}=r.createDelayedPromise();return this.events.once(r.engineEvent("session_request",a),({error:u,result:m})=>{u?h(u):l(m)}),await c()},this.respond=async e=>{this.isInitialized(),await this.isValidRespond(e);const{topic:s,response:t}=e,{id:n}=t;d.isJsonRpcResult(t)?await this.sendResult(n,s,t.result):d.isJsonRpcError(t)&&await this.sendError(n,s,t.error)},this.ping=async e=>{this.isInitialized(),await this.isValidPing(e);const{topic:s}=e;if(this.client.session.keys.includes(s)){const t=await this.sendRequest(s,"wc_sessionPing",{}),{done:n,resolve:a,reject:c}=r.createDelayedPromise();this.events.once(r.engineEvent("session_ping",t),({error:l})=>{l?c(l):a()}),await n()}else this.client.core.pairing.pairings.keys.includes(s)&&await this.client.core.pairing.ping({topic:s})},this.emit=async e=>{this.isInitialized(),await this.isValidEmit(e);const{topic:s,event:t,chainId:n}=e;await this.sendRequest(s,"wc_sessionEvent",{event:t,chainId:n})},this.disconnect=async e=>{this.isInitialized(),await this.isValidDisconnect(e);const{topic:s}=e;this.client.session.keys.includes(s)?(await this.sendRequest(s,"wc_sessionDelete",r.getSdkError("USER_DISCONNECTED")),await this.deleteSession(s)):await this.client.core.pairing.disconnect({topic:s})},this.find=e=>(this.isInitialized(),this.client.session.getAll().filter(s=>r.isSessionCompatible(s,e))),this.deleteSession=async(e,s)=>{const{self:t}=this.client.session.get(e);await this.client.core.relayer.unsubscribe(e),await Promise.all([this.client.session.delete(e,r.getSdkError("USER_DISCONNECTED")),this.client.core.crypto.deleteKeyPair(t.publicKey),this.client.core.crypto.deleteSymKey(e),s?Promise.resolve():this.client.core.expirer.del(e)])},this.deleteProposal=async(e,s)=>{await Promise.all([this.client.proposal.delete(e,r.getSdkError("USER_DISCONNECTED")),s?Promise.resolve():this.client.core.expirer.del(e)])},this.setExpiry=async(e,s)=>{this.client.session.keys.includes(e)&&await this.client.session.update(e,{expiry:s}),this.client.core.expirer.set(e,s)},this.setProposal=async(e,s)=>{await this.client.proposal.set(e,s),this.client.core.expirer.set(e,s.expiry)},this.sendRequest=async(e,s,t)=>{const n=d.formatJsonRpcRequest(s,t),a=await this.client.core.crypto.encode(e,n),c=f[s].req;return this.client.core.history.set(e,n),this.client.core.relayer.publish(e,a,c),n.id},this.sendResult=async(e,s,t)=>{const n=d.formatJsonRpcResult(e,t),a=await this.client.core.crypto.encode(s,n),c=await this.client.core.history.get(s,e),l=f[c.request.method].res;await this.client.core.relayer.publish(s,a,l),await this.client.core.history.resolve(n)},this.sendError=async(e,s,t)=>{const n=d.formatJsonRpcError(e,t),a=await this.client.core.crypto.encode(s,n),c=await this.client.core.history.get(s,e),l=f[c.request.method].res;await this.client.core.relayer.publish(s,a,l),await this.client.core.history.resolve(n)},this.cleanup=async()=>{const e=[],s=[];this.client.session.getAll().forEach(t=>{r.isExpired(t.expiry)&&e.push(t.topic)}),this.client.proposal.getAll().forEach(t=>{r.isExpired(t.expiry)&&s.push(t.id)}),await Promise.all([...e.map(t=>this.deleteSession(t)),...s.map(t=>this.deleteProposal(t))])},this.onRelayEventRequest=e=>{const{topic:s,payload:t}=e,n=t.method;switch(n){case"wc_sessionPropose":return this.onSessionProposeRequest(s,t);case"wc_sessionSettle":return this.onSessionSettleRequest(s,t);case"wc_sessionUpdate":return this.onSessionUpdateRequest(s,t);case"wc_sessionExtend":return this.onSessionExtendRequest(s,t);case"wc_sessionPing":return this.onSessionPingRequest(s,t);case"wc_sessionDelete":return this.onSessionDeleteRequest(s,t);case"wc_sessionRequest":return this.onSessionRequest(s,t);case"wc_sessionEvent":return this.onSessionEventRequest(s,t);default:return this.client.logger.info(`Unsupported request method ${n}`)}},this.onRelayEventResponse=async e=>{const{topic:s,payload:t}=e,n=(await this.client.core.history.get(s,t.id)).request.method;switch(n){case"wc_sessionPropose":return this.onSessionProposeResponse(s,t);case"wc_sessionSettle":return this.onSessionSettleResponse(s,t);case"wc_sessionUpdate":return this.onSessionUpdateResponse(s,t);case"wc_sessionExtend":return this.onSessionExtendResponse(s,t);case"wc_sessionPing":return this.onSessionPingResponse(s,t);case"wc_sessionRequest":return this.onSessionRequestResponse(s,t);default:return this.client.logger.info(`Unsupported response method ${n}`)}},this.onSessionProposeRequest=async(e,s)=>{const{params:t,id:n}=s;try{this.isValidConnect(I({},s.params));const a=r.calcExpiry(p.FIVE_MINUTES),c=I({id:n,pairingTopic:e,expiry:a},t);await this.setProposal(n,c),this.client.events.emit("session_proposal",{id:n,params:c})}catch(a){await this.sendError(n,e,a),this.client.logger.error(a)}},this.onSessionProposeResponse=async(e,s)=>{const{id:t}=s;if(d.isJsonRpcResult(s)){const{result:n}=s;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:n});const a=this.client.proposal.get(t);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:a});const c=a.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:c});const l=n.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:l});const h=await this.client.core.crypto.generateSharedKey(c,l);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:h});const u=await this.client.core.relayer.subscribe(h);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:u}),await this.client.core.pairing.activate({topic:e})}else d.isJsonRpcError(s)&&(await this.client.proposal.delete(t,r.getSdkError("USER_DISCONNECTED")),this.events.emit(r.engineEvent("session_connect"),{error:s.error}))},this.onSessionSettleRequest=async(e,s)=>{const{id:t,params:n}=s;try{this.isValidSessionSettleRequest(n);const{relay:a,controller:c,expiry:l,namespaces:h}=s.params,u={topic:e,relay:a,expiry:l,namespaces:h,acknowledged:!0,controller:c.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:c.publicKey,metadata:c.metadata}};await this.sendResult(s.id,e,!0),this.events.emit(r.engineEvent("session_connect"),{session:u})}catch(a){await this.sendError(t,e,a),this.client.logger.error(a)}},this.onSessionSettleResponse=async(e,s)=>{const{id:t}=s;d.isJsonRpcResult(s)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit(r.engineEvent("session_approve",t),{})):d.isJsonRpcError(s)&&(await this.client.session.delete(e,r.getSdkError("USER_DISCONNECTED")),this.events.emit(r.engineEvent("session_approve",t),{error:s.error}))},this.onSessionUpdateRequest=async(e,s)=>{const{params:t,id:n}=s;try{this.isValidUpdate(I({topic:e},t)),await this.client.session.update(e,{namespaces:t.namespaces}),await this.sendResult(n,e,!0),this.client.events.emit("session_update",{id:n,topic:e,params:t})}catch(a){await this.sendError(n,e,a),this.client.logger.error(a)}},this.onSessionUpdateResponse=(e,s)=>{const{id:t}=s;d.isJsonRpcResult(s)?this.events.emit(r.engineEvent("session_update",t),{}):d.isJsonRpcError(s)&&this.events.emit(r.engineEvent("session_update",t),{error:s.error})},this.onSessionExtendRequest=async(e,s)=>{const{id:t}=s;try{this.isValidExtend({topic:e}),await this.setExpiry(e,r.calcExpiry(N)),await this.sendResult(t,e,!0),this.client.events.emit("session_extend",{id:t,topic:e})}catch(n){await this.sendError(t,e,n),this.client.logger.error(n)}},this.onSessionExtendResponse=(e,s)=>{const{id:t}=s;d.isJsonRpcResult(s)?this.events.emit(r.engineEvent("session_extend",t),{}):d.isJsonRpcError(s)&&this.events.emit(r.engineEvent("session_extend",t),{error:s.error})},this.onSessionPingRequest=async(e,s)=>{const{id:t}=s;try{this.isValidPing({topic:e}),await this.sendResult(t,e,!0),this.client.events.emit("session_ping",{id:t,topic:e})}catch(n){await this.sendError(t,e,n),this.client.logger.error(n)}},this.onSessionPingResponse=(e,s)=>{const{id:t}=s;setTimeout(()=>{d.isJsonRpcResult(s)?this.events.emit(r.engineEvent("session_ping",t),{}):d.isJsonRpcError(s)&&this.events.emit(r.engineEvent("session_ping",t),{error:s.error})},500)},this.onSessionDeleteRequest=async(e,s)=>{const{id:t}=s;try{this.isValidDisconnect({topic:e,reason:s.params}),await this.sendResult(t,e,!0),await this.deleteSession(e),this.client.events.emit("session_delete",{id:t,topic:e})}catch(n){await this.sendError(t,e,n),this.client.logger.error(n)}},this.onSessionRequest=async(e,s)=>{const{id:t,params:n}=s;try{this.isValidRequest(I({topic:e},n)),this.client.events.emit("session_request",{id:t,topic:e,params:n})}catch(a){await this.sendError(t,e,a),this.client.logger.error(a)}},this.onSessionRequestResponse=(e,s)=>{const{id:t}=s;d.isJsonRpcResult(s)?this.events.emit(r.engineEvent("session_request",t),{result:s.result}):d.isJsonRpcError(s)&&this.events.emit(r.engineEvent("session_request",t),{error:s.error})},this.onSessionEventRequest=async(e,s)=>{const{id:t,params:n}=s;try{this.isValidEmit(I({topic:e},n)),this.client.events.emit("session_event",{id:t,topic:e,params:n})}catch(a){await this.sendError(t,e,a),this.client.logger.error(a)}},this.isValidConnect=async e=>{if(!r.isValidParams(e)){const{message:c}=r.getInternalError("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw new Error(c)}const{pairingTopic:s,requiredNamespaces:t,relays:n}=e;r.isUndefined(s)||await this.isValidPairingTopic(s);const a=r.isValidRequiredNamespaces(t,"connect()");if(a)throw new Error(a.message);if(!r.isValidRelays(n,!0)){const{message:c}=r.getInternalError("MISSING_OR_INVALID",`connect() relays: ${n}`);throw new Error(c)}},this.isValidApprove=async e=>{if(!r.isValidParams(e))throw new Error(r.getInternalError("MISSING_OR_INVALID",`approve() params: ${e}`).message);const{id:s,namespaces:t,relayProtocol:n}=e;await this.isValidProposalId(s);const a=this.client.proposal.get(s),c=r.isValidNamespaces(t,"approve()");if(c)throw new Error(c.message);const l=r.isConformingNamespaces(a.requiredNamespaces,t,"update()");if(l)throw new Error(l.message);if(!r.isValidString(n,!0)){const{message:h}=r.getInternalError("MISSING_OR_INVALID",`approve() relayProtocol: ${n}`);throw new Error(h)}},this.isValidReject=async e=>{if(!r.isValidParams(e)){const{message:n}=r.getInternalError("MISSING_OR_INVALID",`reject() params: ${e}`);throw new Error(n)}const{id:s,reason:t}=e;if(await this.isValidProposalId(s),!r.isValidErrorReason(t)){const{message:n}=r.getInternalError("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(t)}`);throw new Error(n)}},this.isValidSessionSettleRequest=e=>{if(!r.isValidParams(e)){const{message:h}=r.getInternalError("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw new Error(h)}const{relay:s,controller:t,namespaces:n,expiry:a}=e;if(!r.isValidRelay(s)){const{message:h}=r.getInternalError("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(h)}const c=r.isValidController(t,"onSessionSettleRequest()");if(c)throw new Error(c.message);const l=r.isValidNamespaces(n,"onSessionSettleRequest()");if(l)throw new Error(l.message);if(r.isExpired(a)){const{message:h}=r.getInternalError("EXPIRED","onSessionSettleRequest()");throw new Error(h)}},this.isValidUpdate=async e=>{if(!r.isValidParams(e)){const{message:l}=r.getInternalError("MISSING_OR_INVALID",`update() params: ${e}`);throw new Error(l)}const{topic:s,namespaces:t}=e;await this.isValidSessionTopic(s);const n=this.client.session.get(s),a=r.isValidNamespaces(t,"update()");if(a)throw new Error(a.message);const c=r.isConformingNamespaces(n.requiredNamespaces,t,"update()");if(c)throw new Error(c.message)},this.isValidExtend=async e=>{if(!r.isValidParams(e)){const{message:t}=r.getInternalError("MISSING_OR_INVALID",`extend() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionTopic(s)},this.isValidRequest=async e=>{if(!r.isValidParams(e)){const{message:c}=r.getInternalError("MISSING_OR_INVALID",`request() params: ${e}`);throw new Error(c)}const{topic:s,request:t,chainId:n}=e;await this.isValidSessionTopic(s);const{namespaces:a}=this.client.session.get(s);if(!r.isValidNamespacesChainId(a,n)){const{message:c}=r.getInternalError("MISSING_OR_INVALID",`request() chainId: ${n}`);throw new Error(c)}if(!r.isValidRequest(t)){const{message:c}=r.getInternalError("MISSING_OR_INVALID",`request() ${JSON.stringify(t)}`);throw new Error(c)}if(!r.isValidNamespacesRequest(a,n,t.method)){const{message:c}=r.getInternalError("MISSING_OR_INVALID",`request() method: ${t.method}`);throw new Error(c)}},this.isValidRespond=async e=>{if(!r.isValidParams(e)){const{message:n}=r.getInternalError("MISSING_OR_INVALID",`respond() params: ${e}`);throw new Error(n)}const{topic:s,response:t}=e;if(await this.isValidSessionTopic(s),!r.isValidResponse(t)){const{message:n}=r.getInternalError("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(t)}`);throw new Error(n)}},this.isValidPing=async e=>{if(!r.isValidParams(e)){const{message:t}=r.getInternalError("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s)},this.isValidEmit=async e=>{if(!r.isValidParams(e)){const{message:c}=r.getInternalError("MISSING_OR_INVALID",`emit() params: ${e}`);throw new Error(c)}const{topic:s,event:t,chainId:n}=e;await this.isValidSessionTopic(s);const{namespaces:a}=this.client.session.get(s);if(!r.isValidNamespacesChainId(a,n)){const{message:c}=r.getInternalError("MISSING_OR_INVALID",`emit() chainId: ${n}`);throw new Error(c)}if(!r.isValidEvent(t)){const{message:c}=r.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(c)}if(!r.isValidNamespacesEvent(a,n,t.name)){const{message:c}=r.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(c)}},this.isValidDisconnect=async e=>{if(!r.isValidParams(e)){const{message:t}=r.getInternalError("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s)}}isInitialized(){if(!this.initialized){const{message:i}=r.getInternalError("NOT_INITIALIZED",this.name);throw new Error(i)}}registerRelayerEvents(){this.client.core.relayer.on(y.RELAYER_EVENTS.message,async i=>{const{topic:e,message:s}=i;if(this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))return;const t=await this.client.core.crypto.decode(e,s);d.isJsonRpcRequest(t)?(this.client.core.history.set(e,t),this.onRelayEventRequest({topic:e,payload:t})):d.isJsonRpcResponse(t)&&(await this.client.core.history.resolve(t),this.onRelayEventResponse({topic:e,payload:t}))})}registerExpirerEvents(){this.client.core.expirer.on(y.EXPIRER_EVENTS.expired,async i=>{const{topic:e,id:s}=r.parseExpirerTarget(i.target);e?this.client.session.keys.includes(e)&&(await this.deleteSession(e,!0),this.client.events.emit("session_expire",{topic:e})):s&&await this.deleteProposal(s,!0)})}isValidPairingTopic(i){if(!r.isValidString(i,!1)){const{message:e}=r.getInternalError("MISSING_OR_INVALID",`pairing topic should be a string: ${i}`);throw new Error(e)}if(!this.client.core.pairing.pairings.keys.includes(i)){const{message:e}=r.getInternalError("NO_MATCHING_KEY",`pairing topic doesn't exist: ${i}`);throw new Error(e)}if(r.isExpired(this.client.core.pairing.pairings.get(i).expiry)){const{message:e}=r.getInternalError("EXPIRED",`pairing topic: ${i}`);throw new Error(e)}}async isValidSessionTopic(i){if(!r.isValidString(i,!1)){const{message:e}=r.getInternalError("MISSING_OR_INVALID",`session topic should be a string: ${i}`);throw new Error(e)}if(!this.client.session.keys.includes(i)){const{message:e}=r.getInternalError("NO_MATCHING_KEY",`session topic doesn't exist: ${i}`);throw new Error(e)}if(r.isExpired(this.client.session.get(i).expiry)){await this.deleteSession(i);const{message:e}=r.getInternalError("EXPIRED",`session topic: ${i}`);throw new Error(e)}}async isValidSessionOrPairingTopic(i){if(this.client.session.keys.includes(i))await this.isValidSessionTopic(i);else if(this.client.core.pairing.pairings.keys.includes(i))this.isValidPairingTopic(i);else if(r.isValidString(i,!1)){const{message:e}=r.getInternalError("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${i}`);throw new Error(e)}else{const{message:e}=r.getInternalError("MISSING_OR_INVALID",`session or pairing topic should be a string: ${i}`);throw new Error(e)}}async isValidProposalId(i){if(!r.isValidId(i)){const{message:e}=r.getInternalError("MISSING_OR_INVALID",`proposal id should be a number: ${i}`);throw new Error(e)}if(!this.client.proposal.keys.includes(i)){const{message:e}=r.getInternalError("NO_MATCHING_KEY",`proposal id doesn't exist: ${i}`);throw new Error(e)}if(r.isExpired(this.client.proposal.get(i).expiry)){await this.deleteProposal(i);const{message:e}=r.getInternalError("EXPIRED",`proposal id: ${i}`);throw new Error(e)}}}class ae extends y.Store{constructor(i,e){super(i,e,U,A),this.core=i,this.logger=e}}class ce extends y.Store{constructor(i,e){super(i,e,$,A),this.core=i,this.logger=e}}class T extends b.ISignClient{constructor(i){super(i),this.protocol=L,this.version=D,this.name=V.name,this.events=new G.EventEmitter,this.on=(s,t)=>this.events.on(s,t),this.once=(s,t)=>this.events.once(s,t),this.off=(s,t)=>this.events.off(s,t),this.removeListener=(s,t)=>this.events.removeListener(s,t),this.connect=async s=>{try{return await this.engine.connect(s)}catch(t){throw this.logger.error(t.message),t}},this.pair=async s=>{try{return await this.engine.pair(s)}catch(t){throw this.logger.error(t.message),t}},this.approve=async s=>{try{return await this.engine.approve(s)}catch(t){throw this.logger.error(t.message),t}},this.reject=async s=>{try{return await this.engine.reject(s)}catch(t){throw this.logger.error(t.message),t}},this.update=async s=>{try{return await this.engine.update(s)}catch(t){throw this.logger.error(t.message),t}},this.extend=async s=>{try{return await this.engine.extend(s)}catch(t){throw this.logger.error(t.message),t}},this.request=async s=>{try{return await this.engine.request(s)}catch(t){throw this.logger.error(t.message),t}},this.respond=async s=>{try{return await this.engine.respond(s)}catch(t){throw this.logger.error(t.message),t}},this.ping=async s=>{try{return await this.engine.ping(s)}catch(t){throw this.logger.error(t.message),t}},this.emit=async s=>{try{return await this.engine.emit(s)}catch(t){throw this.logger.error(t.message),t}},this.disconnect=async s=>{try{return await this.engine.disconnect(s)}catch(t){throw this.logger.error(t.message),t}},this.find=s=>{try{return this.engine.find(s)}catch(t){throw this.logger.error(t.message),t}},this.name=i?.name||V.name,this.metadata=i?.metadata||r.getAppMetadata();const e=typeof i?.logger<"u"&&typeof i?.logger!="string"?i.logger:X.default(x.getDefaultLoggerOptions({level:i?.logger||V.logger}));this.core=i?.core||new y.Core(i),this.logger=x.generateChildLogger(e,this.name),this.session=new ce(this.core,this.logger),this.proposal=new ae(this.core,this.logger),this.engine=new oe(this)}static async init(i){const e=new T(i);return await e.initialize(),e}get context(){return x.getLoggerContext(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.engine.init(),this.logger.info("SignClient Initilization Success")}catch(i){throw this.logger.info("SignClient Initilization Failure"),this.logger.error(i.message),i}}}const le=T;exports.ENGINE_CONTEXT=k,exports.ENGINE_RPC_OPTS=f,exports.HISTORY_CONTEXT=Q,exports.HISTORY_EVENTS=B,exports.HISTORY_STORAGE_VERSION=W,exports.PROPOSAL_CONTEXT=U,exports.PROPOSAL_EXPIRY=ee,exports.SESSION_CONTEXT=$,exports.SESSION_EXPIRY=N,exports.SIGN_CLIENT_CONTEXT=C,exports.SIGN_CLIENT_DEFAULT=V,exports.SIGN_CLIENT_EVENTS=H,exports.SIGN_CLIENT_PROTOCOL=L,exports.SIGN_CLIENT_STORAGE_OPTIONS=Z,exports.SIGN_CLIENT_STORAGE_PREFIX=A,exports.SIGN_CLIENT_VERSION=D,exports.SignClient=le,exports.default=T;
//# sourceMappingURL=index.cjs.js.map
